"""
 -----------------------------------------------------------------------bl-
 --------------------------------------------------------------------------
 
  QUESO - a library to support the Quantification of Uncertainty
  for Estimation, Simulation and Optimization
 
  Copyright (C) 2008,2009,2010,2011,2012,2013 The PECOS Development Team
 
  This library is free software; you can redistribute it and/or
  modify it under the terms of the Version 2.1 GNU Lesser General
  Public License as published by the Free Software Foundation.
 
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.
 
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc. 51 Franklin Street, Fifth Floor,
  Boston, MA  02110-1301  USA
 
-----------------------------------------------------------------------el-

  This module contains a utility funtion, convertMFile, for converting m-files
  generated by QUESO into regular text. See the convertMFile help string for more
  specific information on usage and output. Conversion can also be accomplished
  by invoking convertQuesoMFileToTxt.py on the command line. In this case,
  the script will parse a list of input m-files and create text file output
  for each m-file. The script separates the chain data, likelihood data, and
  target data into separate output files. For more information on the command
  version, run: python convertQuesoMFileToTxt.py --help

"""

import re
import sys

def convertMFile(mFileName, getChain=True, getLike=True,
               getTarget=True, chainIdent='[cC]hain',
               likeIdent='[lL]ikelihood', targetIdent='[tT]arget'):
    """
    
    This function parses chain, likelihood, and target data from a single m-file.
    mFileName specifies the name of m-file to parse. The get{Chain,Like,Target}
    optional inputs take boolean values indicating if the function should parse
    that particular item from the file. The {chain,like,target}Ident optional
    inputs allow the user to specify a regular expression that identifies that
    particular item in the m-file. This function returns a dictionary
    containing keys, 'chain', 'logLikelihood', and 'logTarget'. The value
    associated with a particular key is the data for that item in character
    string format. If the data for an item cannot be found in the file, the
    key for that item will not be present in the dictionary.
    
    """
    
    # tokens delimiting the data 
    dataEncloseTokens = ('[', ']')

    # Read file into string buffer
    fIn = open(mFileName,'r')
    fileBuf = fIn.read()
    fIn.close()

    outputMap = dict()
    parseMap = {'chain': (getChain, chainIdent), 'logLikelihood': (getLike, likeIdent),
                'logTarget': (getTarget, targetIdent)}

    # iterate over wanted items and parse them from the buffer
    for item in parseMap:
        if parseMap[item][0] == False:
            continue
        
        # Find tag for current item via search with regex: identString\w*\s*=\s*(?=\[)
        parseTagRegEx = parseMap[item][1] + r'\w*\s*=\s*' + '(?=' + re.escape(dataEncloseTokens[0]) + ')'
        match = re.search(parseTagRegEx, fileBuf)
        tag = ''
        if match:
            tag = match.group(0) + re.escape(dataEncloseTokens[0])
        else:
            print 'Error: Could not find identifier {0} in {1}. Regex string: {2}'.format(item, mFileName, parseTagRegEx)
            return outputMap

        # Extract current item data between [ ] via search with regex: (?<=tag)[^\]]+
        parseDataRegEx = '(?<=' + tag + ')[^' + re.escape(dataEncloseTokens[1]) + ']+'
        match = re.search(parseDataRegEx, fileBuf)
        if match:
            outputMap[item] = match.group(0)
        else:
            print 'Error: Could not find {0} data in {1}. Regex string: {2}'.format(item, mFileName, parseDataRegEx)
            return outputMap

    return outputMap


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Convert a list of m-files generated by QUESO into text files.')
    parser.add_argument('-c', '--chain', type=str, choices=['yes','no'], default='yes',
                        help='Parse chain data from m-file (default: yes)')
    parser.add_argument('-l', '--likelihood', type=str, choices=['yes','no'], default='yes',
                        help='Parse likelihood data from m-file (default: yes)')
    parser.add_argument('-t', '--target', type=str, choices=['yes','no'], default='yes',
                        help='Parse target data from m-file (default: yes)')
    
    parser.add_argument('-ci', '--chain_identifier', type=str, default='[cC]hain',
                        help='RegEx string identifying chain entry in the m-file (default: [cC]hain)')
    parser.add_argument('-li', '--likelihood_identifier', type=str, default='[lL]ikelihood',
                        help='RegEx string identifying likelihood entry in the m-file (default: [lL]ikelihood)')
    parser.add_argument('-ti', '--target_identifier', type=str, default='[tT]arget',
                        help='RegEx string identifying target entry in the m-file (default: [tT]arget)')

    parser.add_argument('mFileList', nargs='+', help='List of m-files to convert')

    args = parser.parse_args()

    if args.chain == 'yes':
        getChainOpt = True
    else:
        getChainOpt = False

    if args.likelihood == 'yes':
        getLikeOpt = True
    else:
        getLikeOpt = False

    if args.target == 'yes':
        getTargetOpt = True
    else:
        getTargetOpt = False
    
    # process files one-by-one
    for mFileName in args.mFileList:
        outputMap = convertMFile(mFileName, getChain=getChainOpt, getLike=getLikeOpt, getTarget=getTargetOpt, \
                                 chainIdent=args.chain_identifier, likeIdent=args.likelihood_identifier, \
                                 targetIdent=args.target_identifier)

        # Write the data out to text files
        mFileNameBase = mFileName.rstrip('.m')
        for item in outputMap:
            outFileName = mFileNameBase + '_' + item + '.txt'
            fOut = open(outFileName, 'w')
            fOut.write(outputMap[item])
            fOut.close()
            print 'Created file {0}...'.format(outFileName) 
